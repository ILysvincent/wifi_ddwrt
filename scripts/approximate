#!/usr/bin/python

import sys,string
from collections import defaultdict
import rospy
import roslaunch
from wifi_ddwrt.msg import *
import math
import numpy
import tf
import pickle
from geometry_msgs.msg import *
from nav_msgs.srv import *
from visualization_msgs.msg import *
from StringIO import StringIO

class PosEstimate:
  def __init__(self, database):
    self.dic = pickle.load(open( database,"rb"))
    rospy.Subscriber('ddwrt/sitesurvey', SiteSurvey, self.survey_cb)
    self.listener = tf.TransformListener()
    self.pub = rospy.Publisher('ddwrt/posewithcovariance', PoseWithCovarianceStamped)
    self.pose_cov = PoseWithCovarianceStamped()
    self.inv_fp = {}
    self.fp_keys = []
    self.l_rssi = []
    self.rssi_dict = {}

  def sort_by_mac(self,u_dic,arr_pos):
    s_dic = defaultdict(list)
    u_dic_values = list(u_dic.values())
    counter = 0
    for key_ in u_dic.keys():
      n_key = tuple(sorted(list(key_), key=lambda list: list[arr_pos]))
      s_dic[n_key].append(u_dic_values[counter])
      counter += 1
    
    return s_dic

  def invert_keys(self):
    inv_fp = defaultdict(list)
    #inv_fp = {v:k for k, v in self.dic.items()}
    keys_list = self.dic.keys()
    values_list = self.dic.values()

    for x in range(len(self.dic.items())):
      inv_fp[values_list[x]].append(keys_list[x])

    inv_fp = self.sort_by_mac(inv_fp, 1)
    return inv_fp
  
  def get_aps_rssi_list(self,fp_keys):
    rssi_set = []
    l_rssi = []
    for fp_key in fp_keys:
      for ap in fp_key:
        mac = ap[2]
        l_rssi.append(mac)
      rssi_set.append(l_rssi)
 
    return rssi_set

  def match_rssi_to_pos(self,l_rssi,l_pos):
    nt_conv_dict = defaultdict(list)
    for x in range(len(l_rssi)):
      nt_conv_dict[tuple(l_rssi[x])] = l_pos[x]

    return nt_conv_dict

  def take(n, iterable):
    "Return first n items of the iterable as a list"
    a = list(islice(iterable, n))
    return a

  def survey_cb(self, survey):

    r_networks = []

    for s_ap in survey.networks:
      if (s_ap.macaddr == rospy.get_param('macaddr_1') and rospy.get_param('essid_1'))  : r_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_2') and rospy.get_param('essid_2')): r_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_3') and rospy.get_param('essid_3')): r_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_4') and rospy.get_param('essid_4')): r_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_5') and rospy.get_param('essid_5')): r_networks.append((s_ap.rssi,s_ap.macaddr))
      else : x = 0
    
    r_rssi_list = []
    r_networks = numpy.asarray(r_networks)

    r_networks = tuple(sorted(r_networks, key=lambda list: list[1]))
    
    for x in range(len(r_networks)):
      r_rssi_list.append(int(r_networks[x][0]))

    self.convert(r_rssi_list)
  
  def convert(self,r_rssi_list):
    dic_rssi = self.rssi_dict.keys()
    dic_rssi_arr = numpy.asarray(dic_rssi)
    facto_list = []
    r_rssi_list = numpy.asarray(r_rssi_list)

    for x in range(len(self.rssi_dict.keys())):
      dist = numpy.linalg.norm(r_rssi_list - dic_rssi_arr[x])
      a = dist
      b = self.rssi_dict[dic_rssi[x]][0]								#[0] is added due to the extra set of square brackets
      facto_list.append([a,b])

    #print "final_list:", facto_list
    self.calculate_covariance(facto_list)

  def calculate_covariance(self, facto_list):
    s_facto_list = sorted(facto_list)
    dummy = len(s_facto_list)/10
    
    for x in range(dummy+1):
      arr_pos = numpy.array(s_facto_list[x][1]).T

    covar_xy = numpy.cov(arr_pos)[0][1] 
    mean_xy  = arr_pos.mean(axis=1)									# [x,y]
    
    (trans, rot) = self.listener.lookupTransform('/map', '/base_link', rospy.Time(0))
    self.pose_cov.pose.pose.position.x    = mean_xy[0]
    self.pose_cov.pose.pose.position.y    = mean_xy[1]
    self.pose_cov.pose.pose.position.z    = trans[2]
    self.pose_cov.pose.pose.orientation.x = rot[0]
    self.pose_cov.pose.pose.orientation.y = rot[1]
    self.pose_cov.pose.pose.orientation.z = rot[2]
    self.pose_cov.pose.pose.orientation.w = rot[3]
    self.pose_cov.pose.covariance[1]      = covar_xy
    self.pose_cov.pose.covariance[6]      = covar_xy
    
    self.pub.publish(self.pose_cov)

def approximate():
  rospy.init_node('approximate', anonymous=True)
  stri = rospy.get_param('database')
  pe = PosEstimate(stri)
  pe.inv_fp = pe.invert_keys()									   #an inverted dic.
  pe.fp_keys = list(pe.inv_fp.keys())
  pe.fp_values = list(pe.inv_fp.values())
  pe.l_rssi = pe.get_aps_rssi_list(pe.fp_keys)
  pe.rssi_dict = pe.match_rssi_to_pos(pe.l_rssi,pe.fp_values)
  rospy.spin()
     
if __name__ == '__main__':
  approximate()
  
