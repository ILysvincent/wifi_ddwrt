#!/usr/bin/python

import sys,string
from collections import defaultdict
import rospy
import roslaunch
from wifi_ddwrt.msg import *
import math
import numpy
import tf
import pickle
from geometry_msgs.msg import *
from nav_msgs.srv import *
from visualization_msgs.msg import *
from StringIO import StringIO

class PosEstimate:
  def __init__(self, database):
    self.dic = pickle.load(open( database,"rb"))
    self.macadd_list = self.get_list_of_specified_macadd(rospy.get_param('num_aps'))
    rospy.Subscriber('ddwrt/sitesurvey', SiteSurvey, self.survey_cb)
    self.listener = tf.TransformListener()
    self.pub_w_cov = rospy.Publisher('ddwrt/posewithcovariance', PoseWithCovarianceStamped)
    self.pub_pose = rospy.Publisher('ddwrt/pose', PoseStamped)
    self.pose_cov = PoseWithCovarianceStamped()
    self.pose     = PoseStamped()
    self.inv_fp = {}
    self.fp_keys = []
    self.l_rssi = []
    self.rssi_dict = {}

  def get_list_of_specified_macadd(self,num_aps):
    macadd_list = []
    for dummy in range(num_aps):
      statement = 'macaddr_%d' %dummy
      macadd_list.append(rospy.get_param(statement))

    macadd_list = sorted(macadd_list)
    return macadd_list


  def sort_by_mac(self,u_dic,arr_pos):
    s_dic = defaultdict(list)
    u_dic_values = list(u_dic.values())
    counter = 0
    for key_ in u_dic.keys():
      n_key = tuple(sorted(list(key_), key=lambda list: list[arr_pos]))
      s_dic[n_key].append(u_dic_values[counter])
      counter += 1
    
    return s_dic

  def invert_keys(self):
    inv_fp = defaultdict(list)
    #inv_fp = {v:k for k, v in self.dic.items()}
    keys_list = self.dic.keys()
    values_list = self.dic.values()

    for x in range(len(self.dic.items())):
      inv_fp[values_list[x]].append(keys_list[x])

    inv_fp = self.sort_by_mac(inv_fp, 1)
    return inv_fp
  
  def get_aps_rssi_list(self,fp_keys):
    rssi_set = []
    l_rssi = []
    for fp_key in fp_keys:
      for ap in fp_key:
        mac = ap[2]
        l_rssi.append(mac)
      rssi_set.append(l_rssi)
 
    return rssi_set

  def match_rssi_to_pos(self,l_rssi,l_pos):
    nt_conv_dict = defaultdict(list)
    for x in range(len(l_rssi)):
      nt_conv_dict[tuple(l_rssi[x])] = l_pos[x]

    return nt_conv_dict

  def take(n, iterable):
    "Return first n items of the iterable as a list"
    a = list(islice(iterable, n))
    return a

  def survey_cb(self, survey):

    seen_networks = []

    for s_ap in survey.networks:
      if (s_ap.macaddr == rospy.get_param('macaddr_0') and rospy.get_param('essid_0'))  : seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_1') and rospy.get_param('essid_1')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_2') and rospy.get_param('essid_2')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_3') and rospy.get_param('essid_3')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_4') and rospy.get_param('essid_4')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_5') and rospy.get_param('essid_5')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_6') and rospy.get_param('essid_6')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_7') and rospy.get_param('essid_7')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_8') and rospy.get_param('essid_8')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      elif (s_ap.macaddr == rospy.get_param('macaddr_9') and rospy.get_param('essid_9')): seen_networks.append((s_ap.rssi,s_ap.macaddr))
      else : x = 0
    
    seen_rssi = []
    seen_networks = numpy.asarray(seen_networks)

    seen_networks = tuple(sorted(seen_networks, key=lambda list: list[1]))
    
    for x in range(len(seen_networks)):
      seen_rssi.append(int(seen_networks[x][0]))								#A list of macadd-sorted rssi (The currently seen RSSIs)

    index_absent_aps = self.diff_aps(self.macadd_list,seen_rssi)

    self.convert(seen_rssi,survey,index_absent_aps)
  
  def diff_aps(self,macadd_list,seen_rssi):
    index_absent_aps = []
    s = set(seen_rssi)
    absent_aps = [x for x in macadd_list if x not in s]
    for ap in absent_aps:
      index_absent_aps.append(absent_aps.index(ap))

    return index_absent_aps

  def convert(self,seen_rssi,survey,index_absent_aps):
    survey = survey
    dic_rssi = self.rssi_dict.keys()
    dic_rssi_arr = numpy.asarray(dic_rssi)
    facto_list = []
    seen_rssi = numpy.asarray(seen_rssi)

    for x in range(len(self.rssi_dict.keys())):
      for index in index_absent_aps:
        dic_rssi_arr[x][index]= 0									#by setting certain rssi to 0,the keys in the dictionary will not be affected.
      dist = numpy.linalg.norm(seen_rssi - dic_rssi_arr[x])
      a = dist
      b = self.rssi_dict[dic_rssi[x]][0]								#[0] is added due to the extra set of square brackets
      facto_list.append([a,b])
    print seen_rssi
    #print "final_list:", facto_list
    self.calculate_covariance(facto_list,survey)


  def calculate_covariance(self, facto_list, survey):
    s_facto_list = sorted(facto_list)
    dummy = len(s_facto_list)* rospy.get_param('percentage_taken')
    
    for x in range(int(dummy+1)):
      arr_pos = numpy.array(s_facto_list[x][1]).T

    covar_xy = numpy.cov(arr_pos)[0][1] 
    mean_xy  = arr_pos.mean(axis=1)									# [x,y]
    
    (trans, rot) = self.listener.lookupTransform('/map', '/base_link', rospy.Time(0))

    self.pose_cov.header = survey.header
    self.pose_cov.pose.pose.position.x    = mean_xy[0]
    self.pose_cov.pose.pose.position.y    = mean_xy[1]
    self.pose_cov.pose.pose.position.z    = trans[2]
    self.pose_cov.pose.pose.orientation.x = rot[0]
    self.pose_cov.pose.pose.orientation.y = rot[1]
    self.pose_cov.pose.pose.orientation.z = rot[2]
    self.pose_cov.pose.pose.orientation.w = rot[3]
    self.pose_cov.pose.covariance[1]      = covar_xy
    self.pose_cov.pose.covariance[6]      = covar_xy

    self.pose.header             = survey.header
    self.pose.pose.position.x    = mean_xy[0]
    self.pose.pose.position.y    = mean_xy[1]
    self.pose.pose.position.x    = mean_xy[0]
    self.pose.pose.orientation.x = rot[0]    
    self.pose.pose.orientation.y = rot[1]
    self.pose.pose.orientation.z = rot[2]
    self.pose.pose.orientation.w = rot[3]
    
    self.pub_w_cov.publish(self.pose_cov)
    self.pub_pose.publish(self.pose)


def approximate():
  rospy.init_node('approximate', anonymous=True)
  stri = rospy.get_param('database')
  pe = PosEstimate(stri)
  pe.inv_fp = pe.invert_keys()									   #an inverted dic.
  pe.fp_keys = list(pe.inv_fp.keys())
  pe.fp_values = list(pe.inv_fp.values())
  pe.l_rssi = pe.get_aps_rssi_list(pe.fp_keys)
  pe.rssi_dict = pe.match_rssi_to_pos(pe.l_rssi,pe.fp_values)
  rospy.spin()
     
if __name__ == '__main__':
  approximate()
  
