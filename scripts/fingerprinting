#!/usr/bin/python

import sys,string
import rospy
import roslaunch
from wifi_ddwrt.msg import *
import analysis
import math
import tf
import pickle
import json
from geometry_msgs.msg import *
from nav_msgs.srv import *
from visualization_msgs.msg import *
from StringIO import StringIO

class Fingerprints:
    def __init__(self,listener,cell_height,cell_width):
        self.aps = analysis.aps
        self.listener = listener
        self.cell_height = cell_height
        self.cell_width = cell_width
        print self.cell_width
        self.fingerprints = {}
        self.get_map()
        self.num_aps = rospy.get_param('num_aps')
        self.macadd_list = self.get_list_of_specified_macadd(self.num_aps)
        rospy.Subscriber('ddwrt/sitesurvey', SiteSurvey, self.survey_cb)

    def get_list_of_specified_macadd(self,num_aps):
      macadd_list = []
      for dummy in range(num_aps):
        statement = 'macaddr_%d' %dummy
        macadd_list.append(rospy.get_param(statement))

      macadd_list = sorted(macadd_list)
      return macadd_list

    def get_map(self):
        rospy.wait_for_service('static_map')
        try:
            map_service = rospy.ServiceProxy('static_map', GetMap)
            print "Requesting the static map"
            resp = map_service()

            size = (resp.map.info.width, resp.map.info.height)
            self.map_res = resp.map.info.resolution
            self.map_origx= resp.map.info.origin.position.x
            self.map_origy= resp.map.info.origin.position.y
      
        except rospy.ServiceException, e:
            print "The service call to get the map failed"

    def survey_cb(self, survey):
        #we need to get the pose of the robot at the time the survey came in
        try:
            (trans, rot) = self.listener.lookupTransform('/map', '/base_link', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException):
            print "Got an exception that should never happen"
            return

        wanted_networks = []

        for seen_ap in survey.networks:
            if (seen_ap.macaddr == rospy.get_param('macaddr_0') and rospy.get_param('essid_0'))  : related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_1') and rospy.get_param('essid_1')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_2') and rospy.get_param('essid_2')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_3') and rospy.get_param('essid_3')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_4') and rospy.get_param('essid_4')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_5') and rospy.get_param('essid_5')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_6') and rospy.get_param('essid_6')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_7') and rospy.get_param('essid_7')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_8') and rospy.get_param('essid_8')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            elif (seen_ap.macaddr == rospy.get_param('macaddr_9') and rospy.get_param('essid_9')): related_networks.append((seen_ap.essid,seen_ap.macaddr,seen_ap.rssi))
            else : x = 0

        last_trans=[0,0]
        diff_x = round(abs(trans[0]-last_trans[0]),2)
        diff_y = round(abs(trans[1]-last_trans[1]),2)                                              
        index_absent_aps = self.diff_aps(self.macadd_list,related_networks)
        related_networks = sorted(related_networks, key=lambda list: list[1])
        for x in index_absent_aps:								   #This can only be done if the macaddr is filled in ascending order in .yaml
            essid = "essid_%d" %x									    
            macaddr = "macaddr_%d" %x
            related_networks.insert(x,(rospy.get_param(essid),rospy.get_param(macaddr),0))

        if diff_x >= self.cell_width or diff_y >= self.cell_height:
            pos_x= self.rounding(trans[0],self.cell_width)
            pos_y= self.rounding(trans[1],self.cell_height)
            self.fingerprints[pos_x,pos_y]=tuple(related_networks)
            last_trans=trans

    def diff_aps(self,macadd_list,related_networks):
      index_absent_aps = []
      seen_macadd = []
      for ap in related_networks:
          seen_macadd.append(ap[1])
      s = set(seen_macadd)
      absent_aps = [x for x in macadd_list if x not in s]
      absent_aps = sorted(absent_aps)
      for ap in absent_aps:
        index_absent_aps.append(macadd_list.index(ap))

      return index_absent_aps

    def retrieve(self):
        pos_x = float(raw_input("Position x= "))
        pos_y = float(raw_input("Position y= "))
        
        while not((pos_x,pos_y) in self.fingerprints):
            print "Position specified does not exist/available.Please specify another position."
            print self.fingerprints.keys()
            pos_x = float(raw_input("Position x= "))
            if pos_x == -1000:
                return
            pos_y = float(raw_input("Position y= "))

        pos_x = self.rounding(pos_x,self.cell_width)
        pos_y = self.rounding(pos_y,self.cell_height)
         
        print self.fingerprints[pos_x,pos_y]

        return self.fingerprints[pos_x,pos_y]

    def rounding(self, pos, factor):
        counter = 0
        hoF = float(factor)/2
        while pos/factor >= 1.0:
            pos = pos-factor
            counter += 1
        else:
            if float(pos)/hoF >= hoF:
                pos = factor*(counter+1)
                return round(pos,1)
            else:
                pos = counter*factor
                return round(pos,1)

    def save_fingerprints(self):
        database = rospy.get_param('database')
        pickle.dump(self.fingerprints, open(database ,"wb"))
        

def fingerPrints():
    
    c_width= float(rospy.get_param('c_width'))
    c_height= float(rospy.get_param('c_height'))
    if c_width > 5:
        c_width = 5
        print "Specified cell width is too large. Cell width is set to 5"
    elif c_width < 1:
        c_width = 1
        print "Specified cell width is too small. Cell width is set to 1"
    else : x = 0

    if c_height > 5:
        c_height = 5
        print "Specified cell height is too large. Cell height is set to 5"
    elif c_height < 1:
        c_height = 1
        print "Specified cell height is too small. Cell height is set to 1"
    else : x = 0

    rospy.init_node('fingerprinting', anonymous=True)
    listener = tf.TransformListener()
    fp = Fingerprints(listener,c_width,c_height)
    #fp.retrieve()
    rospy.spin()
    fp.save_fingerprints()
    
if __name__ == '__main__':
    fingerPrints()
